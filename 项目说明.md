# OpenWrt 网络监控服务 - 完整说明文档

## 项目概述

这是一个为 ARM 架构 OpenWrt/iStoreOS 软路由设计的轻量级网络监控解决方案，由两部分组成：

1. **OpenWrt 端监控服务** - 纯 Shell 实现，常驻内存 < 10MB
2. **客户端 Web UI** - Flask + SQLite + Docker，提供可视化监控面板

---

## 系统架构

```
┌─────────────────────────────────────────────────────────────────┐
│                       监控系统架构图                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  OpenWrt 路由器 (ARM架构)                 监控客户端 (Docker)       │
│  ┌─────────────────────────┐              ┌──────────────────┐  │
│  │  netmonitor-listener    │              │  Flask Web App   │  │
│  │  (事件监听)              │◄────────────┤  SQLite数据库    │  │
│  └──────────┬──────────────┘              └────────┬─────────┘  │
│             │                                      │            │
│  ┌──────────▼──────────────┐              ┌────────▼─────────┐  │
│  │  netmonitor-api         │─────────────►│  Web Dashboard   │  │
│  │  (HTTP API服务)          │      API     │  + 图表展示      │  │
│  └─────────────────────────┘              └──────────────────┘  │
│          Port: 8321                          Port: 5000          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

数据流：
1. OpenWrt端通过logread/dmesg/ubus监听网络事件
2. 事件存储在内存队列(/tmp/net_events.json)
3. 客户端定时请求API获取实时数据
4. 数据保存到SQLite数据库
5. Web界面展示监控数据和图表
```

---

## OpenWrt 端组件

### 1. 事件监听器 (netmonitor-listener)

**文件**: `netmonitor-listener` (7.4 KB)

**功能**:
- 监听PPPoE连接/断开事件
- 监听WAN接口状态变化
- 监听Kernel网络事件
- 使用流式读取，无轮询，CPU占用 < 1%

**事件类型**:
- `pppoe_up` - PPPoE连接建立
- `pppoe_down` - PPPoE连接断开
- `pppoe_lcp_term` - LCP终止
- `pppoe_padt` - 收到PADT
- `pppoe_auth_fail` - 认证失败
- `wan_up` - WAN接口UP
- `wan_down` - WAN接口DOWN
- `kernel_carrier_lost` - 载波丢失
- `kernel_link_up/down` - 链路状态变化

**资源占用**:
- 内存: 3-5 MB
- CPU: < 1%
- 存储: 仅/tmp (tmpfs)

### 2. HTTP API服务 (netmonitor-api)

**文件**: `netmonitor-api` (11 KB)

**功能**:
- 监听端口 8321
- 提供GET /net/status接口
- 实时采集网络数据
- 返回JSON格式数据

**采集数据项**:
- Ping RTT (223.5.5.5, 8.8.8.8)
- WAN接口错误统计
- 光功率 (GPON)
- CPU温度
- WAN/PPPoE状态
- 事件队列

**资源占用**:
- 内存: 2-3 MB
- 响应时间: < 1000ms

### 3. 启动脚本 (netmonitor)

**文件**: `netmonitor` (3.2 KB)

**功能**:
- procd服务管理
- 支持start/stop/restart/status
- 开机自启配置
- 进程监控和自动重启

**命令**:
```bash
/etc/init.d/netmonitor start    # 启动服务
/etc/init.d/netmonitor stop     # 停止服务
/etc/init.d/netmonitor restart  # 重启服务
/etc/init.d/netmonitor status   # 查看状态
/etc/init.d/netmonitor enable   # 开机自启
/etc/init.d/netmonitor disable  # 禁用自启
```

### 4. 配置文件 (netmonitor.conf)

**文件**: `netmonitor.conf` (1.9 KB)

**配置项**:
```bash
ENABLED=1                          # 是否启用
WAN_IFACE="wan"                    # WAN接口名称
PPPOE_IFACE="pppoe-wan"           # PPPoE接口名称
API_PORT="8321"                    # API端口
ALLOWED_IPS=""                     # IP白名单(空格分隔)
TOKEN=""                          # 访问令牌
PING_TARGETS="223.5.5.5 8.8.8.8" # Ping目标
MAX_EVENTS=200                     # 最大事件数
```

---

## 客户端Web UI组件

### 1. Flask主应用 (app.py)

**文件**: `app.py` (15 KB)

**功能**:
- RESTful API接口
- 数据抓取和存储
- 定时任务管理(APScheduler)
- 数据库ORM操作

**API列表**:
```
GET /                    - 主页
GET /health              - 健康检查
GET /api/status          - 实时状态
GET /api/history         - 历史数据
GET /api/ping_history    - Ping历史
GET /api/events          - 事件列表
GET /api/stats/summary   - 统计摘要
GET /api/fetch_now       - 立即抓取
```

**定时任务**:
- 数据抓取: 每60秒
- 每小时统计: 整点执行
- 数据清理: 每天凌晨3点

**资源占用**:
- 内存: 100-200 MB
- CPU: < 1%
- 存储: 10-50 MB/月

### 2. 数据模型 (models.py)

**文件**: `models.py` (4.6 KB)

**数据表**:

**network_status表** - 网络状态
- id, timestamp, wan_state
- rx_errors, tx_errors, rx_dropped, tx_dropped
- optical_rx, optical_tx, cpu_temp
- pppoe_reconnect_count, wan_down_count

**ping_results表** - Ping结果
- id, timestamp, target, rtt, loss

**network_events表** - 网络事件
- id, timestamp, event_time, event_type, message

**hourly_stats表** - 每小时统计
- id, hour, avg_ping_rtt, max_ping_rtt, min_ping_rtt
- packet_loss_count, pppoe_reconnect_count, wan_down_count
- avg_cpu_temp, max_cpu_temp

### 3. Web界面 (templates/index.html)

**文件**: `templates/index.html` (14.2 KB)

**界面模块**:
1. **状态概览卡片**
   - WAN状态(带指示灯)
   - CPU温度
   - 平均Ping延迟
   - 网络可用性(%)

2. **Ping延迟趋势图**
   - Chart.js交互式图表
   - 时间范围切换(1h/6h/24h)
   - 多目标对比

3. **光功率监控**
   - RX接收功率(dBm)
   - TX发送功率(dBm)

4. **接口错误统计**
   - RX/TX错误数
   - RX/TX丢包数

5. **实时事件列表**
   - 最近20条事件
   - 自动刷新

6. **Ping详情面板**
   - 各目标实时延迟
   - 丢包率

**技术栈**:
- Bootstrap 5.3 (响应式布局)
- Chart.js 4.4.0 (图表)
- Bootstrap Icons (图标)

### 4. Docker配置

**Dockerfile** (533 B)
- 基础镜像: python:3.11-slim
- 安装系统依赖: sqlite3, curl
- 工作目录: /app
- 暴露端口: 5000
- 健康检查

**docker-compose.yml** (1.0 KB)
- 服务: netmonitor-web
- 端口映射: 5000:5000
- 卷挂载: ./data, ./logs
- 环境变量配置
- 可选Nginx服务(profile)

**nginx.conf** (2.2 KB)
- HTTP重定向到HTTPS
- SSL配置
- 安全头部设置
- Gzip压缩
- WebSocket支持

---

## 部署要求

### OpenWrt 路由器要求

**硬件**: ARM架构 (Cortex-A53/A72/NPU)
**系统**: OpenWrt 21.02+ 或 iStoreOS
**依赖**: BusyBox + ash + ubus + netifd
**工具**: grep, sed, awk, ping, ifconfig, logread, dmesg
**端口**: 8321 (可配置)

### 客户端要求

**Docker环境** (推荐):
- Docker 20.10+
- Docker Compose 2.0+

**或者Python环境**:
- Python 3.11+
- SQLite 3

---

## 部署步骤

### 第1步：OpenWrt端部署

**方式A - 使用安装脚本**:
```bash
# 上传文件到路由器
scp netmonitor* root@192.168.1.1:/tmp/

# 登录路由器
ssh root@192.168.1.1

# 运行安装脚本
cd /tmp
sh install.sh

# 配置
vi /etc/netmonitor.conf

# 启动服务
/etc/init.d/netmonitor enable
/etc/init.d/netmonitor start

# 验证
/etc/init.d/netmonitor status
ps | grep netmonitor
tail -f /tmp/net_events.json
```

**方式B - 手动安装**:
```bash
cd /tmp
cp netmonitor-listener /usr/bin/
cp netmonitor-api /usr/bin/
cp netmonitor /etc/init.d/
cp netmonitor.conf /etc/

chmod +x /usr/bin/netmonitor-listener /usr/bin/netmonitor-api
chmod +x /etc/init.d/netmonitor

echo '[]' > /tmp/net_events.json
chmod 644 /tmp/net_events.json

/etc/init.d/netmonitor enable
/etc/init.d/netmonitor start
```

### 第2步：客户端部署

**方式A - Docker部署(推荐)**:
```bash
cd client_web_ui

# 配置环境变量
cp .env.example .env
vi .env  # 修改ROUTER_IP, ROUTER_PORT, ROUTER_TOKEN

# 一键部署
./deploy.sh

# 或者手动
mkdir -p data logs
docker-compose build
docker-compose up -d

# 验证
docker-compose ps
curl http://localhost:5000/health
```

**方式B - Python直接运行**:
```bash
cd client_web_ui

# 安装依赖
pip install -r requirements.txt

# 配置环境变量
export ROUTER_IP=192.168.1.1
export ROUTER_PORT=8321
export ROUTER_TOKEN=your_token
export SQLITE_DB=./data/netmonitor.db

# 运行
python app.py
```

### 第3步：验证完整系统

**OpenWrt端**:
```bash
# 检查进程
ps | grep netmonitor | grep -v grep
# 应显示2个进程: netmonitor-listener, netmonitor-api

# 检查端口
netstat -tlnp | grep 8321
# 应显示监听8321端口

# 测试API
curl http://localhost:8321/net/status
# 应返回JSON数据
```

**客户端**:
```bash
# 检查容器
docker-compose ps
# 状态应为Up

# 测试API
curl http://localhost:5000/api/status
# 应返回路由器数据

# 访问Web界面
open http://localhost:5000
```

---

## 配置说明

### OpenWrt配置 (/etc/netmonitor.conf)

```bash
# 启用/禁用
ENABLED=1

# 接口配置
WAN_IFACE="wan"                    # WAN接口，通过ifconfig查看
PPPOE_IFACE="pppoe-wan"           # PPPoE接口，如使用DHCP则留空

# API配置
API_PORT="8321"                    # API端口，避免冲突

# 安全设置
ALLOWED_IPS="192.168.1.100"       # 允许访问的IP，空格分隔
TOKEN="your-secret-token"          # 访问令牌，建议设置

# Ping目标
PING_TARGETS="223.5.5.5 8.8.8.8"   # 国内+国外DNS

# 事件队列
MAX_EVENTS=200                     # 最大事件数
```

**获取WAN接口名称**:
```bash
ip link show | grep "UP" | awk '{print $2}' | sed 's/:$//'
# 或
ifconfig | grep "Link encap" | awk '{print $1}'
```

**获取PPPoE接口**:
```bash
ifconfig | grep "pppoe" | awk '{print $1}'
```

### 客户端配置 (.env)

```bash
# 路由器配置
ROUTER_IP=192.168.1.1              # OpenWrt路由器IP
ROUTER_PORT=8321                  # API端口
ROUTER_TOKEN=your-secret-token   # 与路由器配置一致

# 抓取间隔
POLL_INTERVAL=60                   # 秒，建议≥30

# Flask配置
FLASK_HOST=0.0.0.0                # 监听地址
FLASK_PORT=5000                   # Web端口
FLASK_DEBUG=false                 # 生产环境设为false

# 数据库路径
SQLITE_DB=./data/netmonitor.db
```

---

## API接口文档

### OpenWrt API (端口 8321)

**GET /net/status**

**请求示例**:
```bash
curl http://192.168.1.1:8321/net/status
# 或带Token
curl -H "Authorization: Bearer TOKEN" http://192.168.1.1:8321/net/status
```

**响应示例**:
```json
{
  "timestamp": "2025-02-12 10:34:00",
  "realtime": {
    "ping": {
      "223.5.5.5": {"rtt": 6.2, "loss": 0},
      "8.8.8.8": {"rtt": 21.4, "loss": 0}
    },
    "wan_errors": {
      "rx_errors": 0,
      "tx_errors": 1,
      "rx_dropped": 0,
      "tx_dropped": 0
    },
    "optical_power": {
      "rx": -8.6,
      "tx": 1.3
    },
    "cpu_temp": 52.8,
    "wan_state": "up"
  },
  "events": [
    {"time": "2025-02-12 10:30:00", "type": "pppoe_up", "message": "PPP连接建立"},
    {"time": "2025-02-12 10:25:12", "type": "wan_down", "message": "WAN接口DOWN"}
  ],
  "summary": {
    "pppoe_reconnect_count_24h": 3,
    "wan_down_count_24h": 1
  }
}
```

### 客户端API (端口 5000)

**GET /api/status**

从路由器获取实时数据

**GET /api/history?hours=24&limit=100**

获取历史数据

**GET /api/ping_history?hours=6&target=8.8.8.8**

获取Ping历史数据

**GET /api/events?limit=50&type=pppoe_up**

获取事件列表

**GET /api/stats/summary?hours=24**

获取统计摘要

**GET /api/fetch_now**

立即从路由器抓取数据

**GET /health**

健康检查

---

## Web界面使用

### 访问方式

```bash
# 本地访问
open http://localhost:5000

# 远程访问(需配置防火墙)
http://your-server-ip:5000
```

### 界面功能

**1. 状态概览卡片**
- WAN状态: 彩色指示灯显示
- CPU温度: 摄氏度(°C)
- 平均延迟: 毫秒(ms)
- 可用性: 百分比(%)

**2. Ping延迟趋势图**
- 鼠标悬停查看详细数据
- 点击图例切换显示/隐藏
- 按钮切换时间范围(1h/6h/24h)

**3. 光功率监控**
- 接收功率(RX): -8 ~ -28 dBm (正常范围)
- 发送功率(TX): 1 ~ 5 dBm (正常范围)

**4. 接口错误统计**
- RX错误/TX错误: 硬件错误计数
- RX丢弃/TX丢弃: 缓冲区溢出计数

**5. 实时事件列表**
- 自动每分钟刷新
- 显示最近20条事件
- 颜色区分事件类型

**6. Ping详情面板**
- 各目标实时延迟
- 丢包率显示

---

## 故障排查

### OpenWrt端问题

**问题1: 服务无法启动**
```bash
# 检查脚本权限
ls -l /usr/bin/netmonitor-* /etc/init.d/netmonitor
# 应有x权限

# 检查配置文件语法
sh -n /etc/netmonitor.conf

# 手动运行测试
/usr/bin/netmonitor-listener &
/usr/bin/netmonitor-api &
ps | grep netmonitor

# 查看系统日志
logread | grep netmonitor
```

**问题2: API无响应**
```bash
# 检查端口监听
netstat -tlnp | grep 8321
# 应显示监听状态

# 从本机测试
curl http://127.0.0.1:8321/net/status

# 检查进程是否运行
ps | grep netmonitor-api

# 检查防火墙
iptables -L INPUT -n | grep 8321
```

**问题3: 事件不记录**
```bash
# 检查logread权限
logread | tail -5

# 检查队列文件
cat /tmp/net_events.json
# 应为JSON格式

# 重置队列
echo '[]' > /tmp/net_events.json
chmod 644 /tmp/net_events.json

# 手动触发测试事件
logger -t pppd "test event"
tail -f /tmp/net_events.json
```

**问题4: 资源占用高**
```bash
# 检查内存占用
ps | grep netmonitor | awk '{print $4}' | awk '{sum+=$1} END {print "Total: " sum " KB"}'
# 应<10MB

# 检查事件队列大小
wc -l /tmp/net_events.json
# 应<=200

# 减少队列大小
sed -i 's/MAX_EVENTS=200/MAX_EVENTS=100/' /etc/netmonitor.conf
/etc/init.d/netmonitor restart
```

### 客户端问题

**问题1: 容器无法启动**
```bash
# 检查Docker环境
docker --version
docker-compose --version

# 查看错误日志
docker-compose logs netmonitor-web

# 检查端口是否被占用
netstat -tlnp | grep 5000

# 检查配置文件
sh -n docker-compose.yml
```

**问题2: 无法连接到路由器**
```bash
# 在容器内测试
 docker exec -it netmonitor-web bash
curl http://192.168.1.1:8321/net/status
# 应返回JSON数据

# 检查网络连通性
ping 192.168.1.1

# 检查环境变量
docker exec -it netmonitor-web env | grep ROUTER
```

**问题3: 数据库错误**
```bash
# 进入容器
docker exec -it netmonitor-web bash

# 检查数据库文件
ls -lh /app/data/netmonitor.db

# 连接数据库
sqlite3 /app/data/netmonitor.db
sqlite> .tables
sqlite> SELECT COUNT(*) FROM network_status;

# 重置数据库(会丢失数据)
rm /app/data/netmonitor.db
# 重启容器自动创建
```

**问题4: Web界面无法访问**
```bash
# 检查容器端口
docker-compose ps
# 应显示5000->5000

# 检查容器日志
docker-compose logs -f netmonitor-web

# 测试API
curl http://localhost:5000/health
# 应返回{"status":"healthy"}

# 从容器内测试
docker exec -it netmonitor-web curl http://localhost:5000/
```

---

## 性能优化建议

### OpenWrt端

1. **减少日志级别**
```bash
# 在/etc/netmonitor.conf中
LOG_LEVEL=1  # 只记录错误
```

2. **调整抓取间隔**
```bash
# 在netmonitor-listener中
# 修改sleep时间
poll_wan_status() {
    while true; do
 sleep 60  # 从30改为60秒n        ...
    done
}
```

3. **禁用不需要的监控**
```bash
# 注释掉不需要的监控函数
# monitor_pppoe &    # 如果不使用PPPoE
# dmesg_monitor &    # 如果不需要Kernel事件
```

### 客户端

1. **调整抓取间隔**
```bash
# 在.env中
POLL_INTERVAL=120  # 从60改为120秒
```

2. **增加数据清理频率**
```bash
# 在app.py中
def cleanup_old_data():
    # 从30天改为7天
    cutoff = datetime.utcnow() - timedelta(days=7)
```

3. **使用Nginx缓存**
```bash
# 在nginx.conf中添加
proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=api:10m;
location /api/ {
    proxy_cache api;
    proxy_cache_valid 200 30s;
    proxy_pass http://netmonitor;
}
```

---

## 扩展功能

### 1. 添加更多Ping目标

编辑 `/etc/netmonitor.conf`:
```bash
PING_TARGETS="223.5.5.5 8.8.8.8 114.114.114.114 1.1.1.1"
```

### 2. 配置邮件告警

创建告警脚本 `alert.sh`:
```bash
#!/bin/sh
# 在OpenWrt上

EMAIL="your@email.com"
SMTP="smtp.gmail.com:587"
USER="your@gmail.com"
PASS="your-password"

check_wan() {
    STATUS=$(curl -s http://localhost:8321/net/status | grep -o '"wan_state":"[^"]*"' | cut -d'"' -f4)
    if [ "$STATUS" != "up" ]; then
        echo "WAN down at $(date)" | msmtp --host=$SMTP --user=$USER --pass=$PASS $EMAIL
    fi
}

# 每5分钟检查
while true; do
    check_wan
    sleep 300
done
```

### 3. 集成Prometheus

在app.py中添加:
```python
from prometheus_client import Counter, Gauge, generate_latest

# 定义指标
ping_rtt = Gauge('ping_rtt_ms', 'Ping RTT', ['target'])
cpu_temp = Gauge('cpu_temp_celsius', 'CPU Temperature')
wan_status = Gauge('wan_status', 'WAN Status')

@app.route('/metrics')
def metrics():
    # 收集指标
    data = fetch_router_data()
    if data:
        for target, ping in data['realtime']['ping'].items():
            ping_rtt.labels(target=target).set(ping['rtt'])
        cpu_temp.set(data['realtime']['cpu_temp'])
        wan_status.set(1 if data['realtime']['wan_state'] == 'up' else 0)

    return Response(generate_latest(), mimetype='text/plain')
```

### 4. 多路由器监控

修改docker-compose.yml:
```yaml
services:
  netmonitor-web-router1:
    environment:
      - ROUTER_IP=192.168.1.1
      - ROUTER_PORT=8321
      - ROUTER_TOKEN=token1

  netmonitor-web-router2:
    environment:
      - ROUTER_IP=192.168.1.2
      - ROUTER_PORT=8321
      - ROUTER_TOKEN=token2
    ports:
      - "5001:5000"
```

---

## 备份与恢复

### OpenWrt端备份

```bash
# 备份配置文件
cp /etc/netmonitor.conf /backup/

# 备份脚本
cp /usr/bin/netmonitor-listener /backup/
cp /usr/bin/netmonitor-api /backup/
cp /etc/init.d/netmonitor /backup/

# 备份事件队列(可选)
cp /tmp/net_events.json /backup/
```

### 恢复

```bash
cp /backup/netmonitor-listener /usr/bin/
cp /backup/netmonitor-api /usr/bin/
cp /backup/netmonitor /etc/init.d/
cp /backup/netmonitor.conf /etc/

chmod +x /usr/bin/netmonitor-* /etc/init.d/netmonitor
/etc/init.d/netmonitor start
```

### 客户端备份

```bash
# 备份数据库
docker exec netmonitor-web sqlite3 /app/data/netmonitor.db ".backup /app/data/backup.db"
cp data/backup.db /backup/

# 备份配置
cp .env docker-compose.yml /backup/
```

### 恢复

```bash
cp /backup/netmonitor.db data/
cp /backup/.env .
docker-compose up -d
```

---

## 卸载系统

### 卸载OpenWrt端

```bash
# 停止服务
/etc/init.d/netmonitor stop
/etc/init.d/netmonitor disable

# 删除文件
rm -f /usr/bin/netmonitor-listener
rm -f /usr/bin/netmonitor-api
rm -f /etc/init.d/netmonitor
rm -f /etc/netmonitor.conf
rm -f /tmp/net_events.json

# 清理日志
logread | grep netmonitor > /dev/null
```

### 卸载客户端

```bash
# 停止容器
docker-compose down

# 删除镜像
docker rmi netmonitor-web

# 删除数据(如不需要备份)
rm -rf data logs

# 删除代码
rm -rf client_web_ui
```

---

## 监控指标参考

### 正常范围

| 指标 | 正常范围 | 说明 |
|------|---------|------|
| CPU温度 | 30-70°C | ARM路由器典型值 |
| Ping延迟(国内) | 5-50ms | 到223.5.5.5 |
| Ping延迟(国际) | 50-300ms | 到8.8.8.8 |
| 丢包率 | 0-1% | 应<1% |
| 光功率RX | -8 ~ -28 dBm | GPON标准 |
| 光功率TX | 1 ~ 5 dBm | GPON标准 |
| RX/TX错误 | 0 | 应无错误 |

### 警告阈值

| 指标 | 警告 | 严重 |
|------|------|------|
| CPU温度 | > 75°C | > 85°C |
| 延迟 | > 100ms | > 500ms |
| 丢包率 | > 1% | > 5% |
| 光功率RX | -28 ~ -30 dBm | < -30 dBm |
| RX错误 | > 0 | > 10 |

---

## 开发说明

### 代码结构

```
/Volumes/Mr.Meng/Meng-Code/openwrt_monitor/
├── OpenWrt端
│   ├── netmonitor-listener    # 事件监听器
│   ├── netmonitor-api         # HTTP API
│   ├── netmonitor             # 启动脚本
│   ├── netmonitor.conf        # 配置文件
│   ├── install.sh             # 安装脚本
│   ├── README.md              # 详细文档
│   └── QUICKSTART.md          # 快速开始
│
└── 客户端Web UI
    ├── app.py                 # Flask应用
    ├── models.py              # 数据模型
    ├── requirements.txt       # Python依赖
    ├── Dockerfile             # Docker配置
    ├── docker-compose.yml     # Docker Compose
    ├── nginx.conf             # Nginx配置
    ├── deploy.sh              # 部署脚本
    ├── .env                   # 环境变量
    ├── .env.example           # 环境变量模板
    ├── README.md              # 详细文档
    ├── 文件清单.txt           # 文件说明
    └── templates/
        └── index.html         # Web界面
```

### 修改建议

**OpenWrt端**:
- 所有脚本纯Shell实现，可直接修改
- 注意保持JSON格式正确
- 测试时使用`sh -n script.sh`检查语法

**客户端**:
- 使用Flask框架，遵循MVC模式
- 数据库模型修改后需迁移
- 前端使用Bootstrap和Chart.js

---

## 常见问题

### Q1: 支持哪些OpenWrt版本?
A: OpenWrt 21.02+, iStoreOS, 需要ash/bash环境

### Q2: 支持其他架构吗?
A: 主要为ARM优化, 也可在MIPS/x86上运行(需调整温度读取)

### Q3: 数据存储多久?
A: OpenWrt端: 200条事件循环覆盖; 客户端: 30天自动清理

### Q4: 可以监控多个路由器吗?
A: 可以, 部署多个客户端实例, 配置不同的ROUTER_IP

### Q5: 支持公网访问吗?
A: 支持, 但建议使用VPN或SSH隧道, 配置ALLOWED_IPS和TOKEN

### Q6: 数据库可以换成MySQL/PostgreSQL吗?
A: 可以, 修改app.py中的SQLALCHEMY_DATABASE_URI即可

### Q7: 如何升级?
A: OpenWrt端: 替换脚本文件; 客户端: 重新构建Docker镜像

---

## 许可证

MIT License - 免费使用, 允许商业用途

---

## 联系方式

- 问题反馈: GitHub Issues
- 功能建议: GitHub Discussions
- 贡献代码: GitHub Pull Requests

---

## 版本历史

### v1.0.0 (2025-12-08)
- 初始版本
- OpenWrt端纯Shell实现
- 客户端Flask + SQLite
- Docker容器化部署
- 响应式Web界面
- 完整API接口

---

**文档生成时间**: 2025-12-08
**文档版本**: v1.0.0
